{
  "files": [
    {
      "name": "tasks.py",
      "path": "dealer_sync_backend/scraper/tasks.py",
      "size": 5026,
      "type": "text",
      "content": "from celery import shared_task\nfrom .scraper import run_all_scrapers\nfrom .models import SyncAttempt, VehicleListing\nfrom django.contrib.auth import get_user_model\nfrom django.utils import timezone\nfrom celery.utils.log import get_task_logger\nfrom channels.layers import get_channel_layer\nfrom asgiref.sync import async_to_sync\nimport json\n\nlogger = get_task_logger(__name__)\n\n\n@shared_task(bind=True)\ndef run_scrapers(self, user_id):\n    channel_layer = get_channel_layer()\n    User = get_user_model()\n    sync_attempt = None\n\n    def update_progress(current, total, current_vehicle):\n        progress = int((current / total) * 100) if total > 0 else 0\n        message = {\n            'user_id': user_id,\n            'current': current,\n            'total': total,\n            'percent': progress,\n            'currentVehicle': current_vehicle\n        }\n        self.update_state(state='PROGRESS', meta=message)\n        try:\n            async_to_sync(channel_layer.group_send)(\n                f'sync_{user_id}',\n                {\n                    'type': 'sync_message',\n                    'message': json.dumps(message)\n                }\n            )\n            logger.info(f\"WebSocket message sent: {message}\")\n        except Exception as e:\n            logger.error(f\"Failed to send WebSocket message: {str(e)}\")\n        logger.info(f\"Updated task state: {\n                    progress}% complete, current vehicle: {current_vehicle}\")\n\n    try:\n        user = User.objects.get(id=user_id)\n        sync_attempt = SyncAttempt.objects.create(\n            user=user,\n            status='IN_PROGRESS',\n            task_id=self.request.id\n        )\n\n        update_progress(0, 100, 'Starting scrape...')\n        logger.info(f\"Starting scrape for user {user_id}\")\n\n        listings = run_all_scrapers(user_id) or []\n        logger.info(f\"Scraped {len(listings)} listings\")\n\n        if not listings:\n            logger.warning(\"No listings returned from scraper\")\n            sync_attempt.status = 'COMPLETED'\n            sync_attempt.end_time = timezone.now()\n            sync_attempt.save()\n            update_progress(100, 100, 'No listings found')\n            return \"No listings found\"\n\n        listings_added = 0\n        listings_updated = 0\n        total_listings = len(listings)\n\n        for index, listing_data in enumerate(listings, start=1):\n            unique_identifier = listing_data.get('unique_identifier')\n            if not unique_identifier:\n                logger.warning(\n                    f\"Skipping listing without unique identifier: {listing_data}\")\n                continue\n\n            current_vehicle = f\"{listing_data.get(\n                'year', 'N/A')} {listing_data.get('make', 'N/A')} {listing_data.get('model', 'N/A')}\"\n\n            try:\n                listing, created = VehicleListing.objects.update_or_create(\n                    user=user,\n                    unique_identifier=unique_identifier,\n                    defaults={\n                        'dealership': listing_data.get('dealership'),\n                        'title': listing_data.get('title'),\n                        'price': listing_data.get('price'),\n                        'msrp': listing_data.get('msrp'),\n                        'year': listing_data.get('year'),\n                        'make': listing_data.get('make'),\n                        'model': listing_data.get('model'),\n                        'image_url': listing_data.get('image_url'),\n                        'needs_update': False\n                    }\n                )\n\n                if created:\n                    listings_added += 1\n                else:\n                    listings_updated += 1\n\n                update_progress(index, total_listings, current_vehicle)\n            except Exception as e:\n                logger.error(f\"Error processing listing {\n                             unique_identifier}: {str(e)}\")\n\n        # Mark listings that weren't updated as needing update\n        VehicleListing.objects.filter(\n            user=user,\n            updated_at__lt=timezone.now() - timezone.timedelta(hours=1)\n        ).update(needs_update=True)\n\n        sync_attempt.status = 'COMPLETED'\n        sync_attempt.listings_added = listings_added\n        sync_attempt.listings_updated = listings_updated\n        sync_attempt.end_time = timezone.now()\n        sync_attempt.save()\n\n        logger.info(f\"Scraping completed. Added: {\n                    listings_added}, Updated: {listings_updated}\")\n        update_progress(total_listings, total_listings, 'Scraping completed')\n        return f\"Scraping completed successfully. Added: {listings_added}, Updated: {listings_updated}\"\n\n    except Exception as e:\n        logger.error(f\"Error in run_scrapers task: {str(e)}\")\n        if sync_attempt:\n            sync_attempt.status = 'FAILED'\n            sync_attempt.error_message = str(e)\n            sync_attempt.end_time = timezone.now()\n            sync_attempt.save()\n        update_progress(0, 100, f'Error: {str(e)}')\n        raise\n",
      "line_count": 132
    },
    {
      "name": "consumers.py",
      "path": "dealer_sync_backend/scraper/consumers.py",
      "size": 2546,
      "type": "text",
      "content": "import json\nimport logging\nfrom channels.generic.websocket import AsyncWebsocketConsumer\nfrom channels.exceptions import DenyConnection\n\nlogger = logging.getLogger(__name__)\n\n\nclass SyncConsumer(AsyncWebsocketConsumer):\n    async def connect(self):\n        try:\n            self.user = self.scope.get(\"user\")\n            if not self.user or not self.user.is_authenticated:\n                raise DenyConnection(\"User is not authenticated\")\n\n            self.sync_group_name = f'sync_{self.user.id}'\n            logger.info(f\"WebSocket connection attempt for user {\n                        self.user.id}\")\n\n            # Join sync group\n            await self.channel_layer.group_add(\n                self.sync_group_name,\n                self.channel_name\n            )\n            logger.info(f\"User {self.user.id} added to group {\n                        self.sync_group_name}\")\n            await self.accept()\n        except Exception as e:\n            logger.error(f\"Error in connect: {str(e)}\")\n            raise\n\n    async def disconnect(self, close_code):\n        try:\n            if hasattr(self, 'sync_group_name'):\n                # Leave sync group\n                await self.channel_layer.group_discard(\n                    self.sync_group_name,\n                    self.channel_name\n                )\n                logger.info(f\"User {self.user.id} disconnected from group {\n                            self.sync_group_name}\")\n        except Exception as e:\n            logger.error(f\"Error in disconnect: {str(e)}\")\n\n    async def receive(self, text_data):\n        try:\n            text_data_json = json.loads(text_data)\n            message = text_data_json['message']\n            logger.info(f\"Received message from user {\n                        self.user.id}: {message}\")\n\n            # Send message to sync group\n            await self.channel_layer.group_send(\n                self.sync_group_name,\n                {\n                    'type': 'sync_message',\n                    'message': message\n                }\n            )\n        except Exception as e:\n            logger.error(f\"Error in receive: {str(e)}\")\n\n    async def sync_message(self, event):\n        try:\n            message = event['message']\n            logger.info(f\"Sending message to user {self.user.id}: {message}\")\n\n            # Send message to WebSocket\n            await self.send(text_data=json.dumps({\n                'message': message\n            }))\n        except Exception as e:\n            logger.error(f\"Error in sync_message: {str(e)}\")\n",
      "line_count": 73
    },
    {
      "name": "views.py",
      "path": "dealer_sync_backend/authentication/views.py",
      "size": 1747,
      "type": "text",
      "content": "from django.shortcuts import render\nfrom rest_framework import status\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom rest_framework.permissions import IsAuthenticated, BasePermission\nfrom rest_framework_simplejwt.tokens import RefreshToken\nfrom rest_framework_simplejwt.views import TokenObtainPairView\nfrom rest_framework_simplejwt.serializers import TokenObtainPairSerializer\nfrom .serializers import UserSerializer\nfrom typing import List\n\n\nclass RegisterView(APIView):\n\n    permission_classes: List[type[BasePermission]] = []\n\n    def post(self, request):\n        serializer = UserSerializer(data=request.data)\n        if serializer.is_valid():\n            user = serializer.save()\n            refresh = RefreshToken.for_user(user)\n            return Response({\n                'user': serializer.data,\n                'refresh': str(refresh),\n                'access': str(refresh.access_token),\n            }, status=status.HTTP_201_CREATED)\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\n\nclass CustomTokenObtainPairSerializer(TokenObtainPairSerializer):\n    def validate(self, attrs):\n        data = super().validate(attrs)\n        refresh = self.get_token(self.user)\n        data['refresh'] = str(refresh)\n        data['access'] = str(refresh.access_token)\n        data['user'] = UserSerializer(self.user).data\n        return data\n\n\nclass CustomTokenObtainPairView(TokenObtainPairView):\n    serializer_class = CustomTokenObtainPairSerializer\n\n\nclass UserView(APIView):\n\n    permission_classes: List[type[BasePermission]] = [IsAuthenticated]\n\n    def get(self, request):\n        serializer = UserSerializer(request.user)\n        return Response(serializer.data)\n",
      "line_count": 50
    },
    {
      "name": "views.py",
      "path": "dealer_sync_backend/scraper/views.py",
      "size": 9339,
      "type": "text",
      "content": "from rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework.permissions import IsAuthenticated, BasePermission\nfrom .tasks import run_scrapers\nfrom .models import SyncAttempt, VehicleListing\nfrom celery.result import AsyncResult\nfrom django.utils import timezone\nfrom celery.exceptions import OperationalError\nfrom .serializers import VehicleListingSerializer\nfrom django.core.exceptions import FieldError\nfrom django.db.models import Count\nfrom typing import List\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass StartScraperView(APIView):\n    permission_classes = [IsAuthenticated]\n\n    def post(self, request):\n        try:\n            logger.info(f\"Starting scraper task for user {request.user.id}\")\n            task = run_scrapers.delay(request.user.id)\n            sync_attempt = SyncAttempt.objects.create(\n                user=request.user,\n                task_id=task.id,\n                status='PENDING'\n            )\n            logger.info(f\"Scraper task started. Task ID: {task.id}\")\n            return Response({\"message\": \"Scraper task started\", \"task_id\": str(task.id)})\n        except OperationalError as e:\n            logger.error(f\"OperationalError while starting scraper: {str(e)}\")\n            return Response({\"error\": \"Could not connect to task queue. Please try again later.\"}, status=503)\n        except Exception as e:\n            logger.exception(\n                f\"Unexpected error while starting scraper: {str(e)}\")\n            return Response({\"error\": \"An unexpected error occurred. Please try again.\"}, status=500)\n\n\nclass ScraperStatusView(APIView):\n    permission_classes = [IsAuthenticated]\n\n    def get(self, request):\n        task_id = request.query_params.get('task_id')\n        user_id = request.user.id\n        logger.info(f\"Checking scraper status. Task ID: {\n                    task_id}, User ID: {user_id}\")\n\n        if not task_id:\n            logger.warning(\"No task_id provided in request\")\n            return Response({\"error\": \"No task_id provided\"}, status=400)\n\n        try:\n            sync_attempt = SyncAttempt.objects.filter(\n                task_id=task_id, user_id=user_id).first()\n            if not sync_attempt:\n                logger.warning(f\"No sync attempt found for task {\n                               task_id} and user {user_id}\")\n                return Response({\"error\": \"No sync attempt found for this task and user\"}, status=404)\n\n            task_result = AsyncResult(task_id)\n            logger.info(f\"Task state: {task_result.state}\")\n\n            response = {\n                'state': task_result.state,\n                'userId': user_id,\n            }\n\n            if task_result.state == 'PENDING':\n                response['status'] = 'Sync task is pending...'\n            elif task_result.state == 'PROGRESS':\n                info = task_result.info or {}\n                response.update({\n                    'current': info.get('current', 0),\n                    'total': info.get('total', 'unknown'),\n                    'percent': info.get('percent', 0),\n                    'status': f\"Processing vehicle {info.get('current', 0)} of {info.get('total', 'unknown')}\",\n                    'currentVehicle': info.get('currentVehicle', 'Unknown'),\n                })\n                logger.info(f\"Returning progress response: {response}\")\n            elif task_result.state == 'SUCCESS':\n                response['status'] = task_result.result\n            else:\n                response['status'] = str(task_result.info)\n\n            logger.info(f\"Returning response for task {task_id}: {response}\")\n            return Response(response)\n        except Exception as e:\n            logger.exception(\n                f\"Unexpected error while checking scraper status: {str(e)}\")\n            return Response({\"error\": \"An unexpected error occurred. Please try again.\"}, status=500)\n\n\nclass DumpListingsView(APIView):\n    permission_classes: List[type[BasePermission]] = [IsAuthenticated]\n\n    def get(self, request):\n        try:\n            logger.info(f\"Fetching listings for user {request.user.id}\")\n            listings = VehicleListing.objects.filter(user=request.user)\n            serializer = VehicleListingSerializer(listings, many=True)\n            logger.info(f\"Retrieved {listings.count()\n                                     } listings for user {request.user.id}\")\n            return Response({\n                \"count\": listings.count(),\n                \"listings\": serializer.data\n            })\n        except FieldError as e:\n            logger.error(f\"FieldError while fetching listings: {str(e)}\")\n            return Response({\"error\": f\"FieldError: {str(e)}\"}, status=400)\n        except Exception as e:\n            logger.exception(\n                f\"Unexpected error while fetching listings: {str(e)}\")\n            return Response({\"error\": f\"An unexpected error occurred: {str(e)}\"}, status=500)\n\n\nclass SyncHistoryView(APIView):\n    permission_classes: List[type[BasePermission]] = [IsAuthenticated]\n\n    def get(self, request):\n        user = request.user\n        today = timezone.now().date()\n        logger.info(f\"Fetching sync history for user {user.id}\")\n\n        try:\n            last_successful = SyncAttempt.objects.filter(\n                user=user, status='COMPLETED').order_by('-end_time').first()\n            sync_history = {\n                \"lastSuccessful\": last_successful.end_time.isoformat() if last_successful else None,\n                \"totalToday\": SyncAttempt.objects.filter(user=user, start_time__date=today).count(),\n                \"failedToday\": SyncAttempt.objects.filter(user=user, start_time__date=today, status='FAILED').count()\n            }\n            logger.info(f\"Sync history for user {user.id}: {sync_history}\")\n            return Response(sync_history)\n        except Exception as e:\n            logger.exception(f\"Error fetching sync history for user {\n                             user.id}: {str(e)}\")\n            return Response({\"error\": \"Failed to fetch sync history\"}, status=500)\n\n\nclass DashboardView(APIView):\n    permission_classes: List[type[BasePermission]] = [IsAuthenticated]\n\n    def get(self, request):\n        user = request.user\n        logger.info(f\"Fetching dashboard data for user {user.id}\")\n\n        try:\n            total_listings = VehicleListing.objects.filter(user=user).count()\n            today = timezone.now().date()\n            listings_today = VehicleListing.objects.filter(\n                user=user, created_at__date=today).count()\n\n            active_syncs = SyncAttempt.objects.filter(\n                user=user, status='IN_PROGRESS').count()\n            pending_updates = VehicleListing.objects.filter(\n                user=user, needs_update=True).count()\n            total_views = VehicleListing.objects.filter(user=user).aggregate(\n                total_views=Count('views'))['total_views']\n\n            # Get data for chart (last 4 months)\n            chart_data = []\n            for i in range(3, -1, -1):\n                month_start = (timezone.now() -\n                               timezone.timedelta(days=30*i)).replace(day=1)\n                month_end = (month_start + timezone.timedelta(days=32)\n                             ).replace(day=1) - timezone.timedelta(days=1)\n                listings_count = VehicleListing.objects.filter(\n                    user=user, created_at__range=(month_start, month_end)).count()\n                views_count = VehicleListing.objects.filter(user=user, created_at__range=(\n                    month_start, month_end)).aggregate(total_views=Count('views'))['total_views']\n                chart_data.append({\n                    \"name\": month_start.strftime(\"%b\"),\n                    \"listings\": listings_count,\n                    \"views\": views_count\n                })\n\n            # Recent activity (last 4 events)\n            recent_listings = VehicleListing.objects.filter(\n                user=user).order_by('-created_at')[:4]\n            recent_activity = [\n                {\n                    \"title\": \"New Listing Added\",\n                    \"description\": f\"{listing.year} {listing.make} {listing.model}\",\n                    \"time\": f\"{(timezone.now() - listing.created_at).days} days ago\"\n                } for listing in recent_listings\n            ]\n\n            dashboard_data = {\n                \"stats\": [\n                    {\"title\": \"Total Listings\",\n                        \"value\": total_listings, \"icon\": \"Car\"},\n                    {\"title\": \"Active Syncs\",\n                        \"value\": active_syncs, \"icon\": \"Activity\"},\n                    {\"title\": \"Pending Updates\",\n                        \"value\": pending_updates, \"icon\": \"Clock\"},\n                    {\"title\": \"Total Views\", \"value\": total_views, \"icon\": \"Eye\"},\n                ],\n                \"recentActivity\": recent_activity,\n                \"chartData\": chart_data\n            }\n            logger.info(\n                f\"Dashboard data fetched successfully for user {user.id}\")\n            return Response(dashboard_data)\n        except Exception as e:\n            logger.exception(f\"Error fetching dashboard data for user {\n                             user.id}: {str(e)}\")\n            return Response({\"error\": \"Failed to fetch dashboard data\"}, status=500)\n",
      "line_count": 209
    },
    {
      "name": "views.py",
      "path": "dealer_sync_backend/dashboard/views.py",
      "size": 4528,
      "type": "text",
      "content": "from rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework.permissions import IsAuthenticated, BasePermission\nfrom scraper.tasks import run_scrapers\nfrom scraper.models import VehicleListing, SyncAttempt\nfrom .serializers import VehicleListingSerializer\nfrom rest_framework.pagination import PageNumberPagination\nfrom django.db.models import Count\nfrom django.utils import timezone\nfrom datetime import timedelta\nfrom typing import List\n\n\nclass DashboardView(APIView):\n\n    permission_classes: List[type[BasePermission]] = [IsAuthenticated]\n\n    def get(self, request):\n        user = request.user\n        total_listings = VehicleListing.objects.filter(user=user).count()\n        today = timezone.now().date()\n        listings_today = VehicleListing.objects.filter(\n            user=user, created_at__date=today).count()\n\n        active_syncs = SyncAttempt.objects.filter(\n            user=user, status='IN_PROGRESS').count()\n        pending_updates = VehicleListing.objects.filter(\n            user=user, needs_update=True).count()\n        total_views = VehicleListing.objects.filter(user=user).aggregate(\n            total_views=Count('views'))['total_views']\n\n        # Get data for chart (last 4 months)\n        chart_data = []\n        for i in range(3, -1, -1):\n            month_start = (timezone.now() -\n                           timedelta(days=30*i)).replace(day=1)\n            month_end = (month_start + timedelta(days=32)\n                         ).replace(day=1) - timedelta(days=1)\n            listings_count = VehicleListing.objects.filter(\n                user=user, created_at__range=(month_start, month_end)).count()\n            views_count = VehicleListing.objects.filter(user=user, created_at__range=(\n                month_start, month_end)).aggregate(total_views=Count('views'))['total_views']\n            chart_data.append({\n                \"name\": month_start.strftime(\"%b\"),\n                \"listings\": listings_count,\n                \"views\": views_count\n            })\n\n        # Recent activity (last 4 events)\n        recent_listings = VehicleListing.objects.filter(\n            user=user).order_by('-created_at')[:4]\n        recent_activity = [\n            {\n                \"title\": \"New Listing Added\",\n                \"description\": f\"{listing.year} {listing.make} {listing.model}\",\n                \"time\": f\"{(timezone.now() - listing.created_at).days} days ago\"\n            } for listing in recent_listings\n        ]\n\n        dashboard_data = {\n            \"stats\": [\n                {\"title\": \"Total Listings\", \"value\": total_listings, \"icon\": \"Car\"},\n                {\"title\": \"Active Syncs\", \"value\": active_syncs, \"icon\": \"Activity\"},\n                {\"title\": \"Pending Updates\",\n                    \"value\": pending_updates, \"icon\": \"Clock\"},\n                {\"title\": \"Total Views\", \"value\": total_views, \"icon\": \"Eye\"},\n            ],\n            \"recentActivity\": recent_activity,\n            \"chartData\": chart_data\n        }\n        return Response(dashboard_data)\n\n\nclass ListingsView(APIView):\n\n    permission_classes: List[type[BasePermission]] = [IsAuthenticated]\n\n    def get(self, request):\n        paginator = PageNumberPagination()\n        paginator.page_size = 20\n        listings = VehicleListing.objects.filter(\n            user=request.user).order_by('-created_at')\n        result_page = paginator.paginate_queryset(listings, request)\n        serializer = VehicleListingSerializer(result_page, many=True)\n        return paginator.get_paginated_response(serializer.data)\n\n\nclass SyncHistoryView(APIView):\n\n    permission_classes: List[type[BasePermission]] = [IsAuthenticated]\n\n    def get(self, request):\n        today = timezone.now().date()\n        last_successful = SyncAttempt.objects.filter(\n            status='COMPLETED').order_by('-end_time').first()\n        sync_history = {\n            \"lastSuccessful\": last_successful.end_time if last_successful else None,\n            \"totalToday\": SyncAttempt.objects.filter(start_time__date=today).count(),\n            \"failedToday\": SyncAttempt.objects.filter(start_time__date=today, status='FAILED').count()\n        }\n        return Response(sync_history)\n\n\nclass SyncStartView(APIView):\n\n    permission_classes: List[type[BasePermission]] = [IsAuthenticated]\n\n    def post(self, request):\n        # Trigger the Celery task\n        task = run_scrapers.delay()\n        return Response({\n            \"message\": \"Sync process started\",\n            \"task_id\": task.id\n        })\n",
      "line_count": 114
    },
    {
      "name": "models.py",
      "path": "dealer_sync_backend/authentication/models.py",
      "size": 57,
      "type": "text",
      "content": "from django.db import models\n\n# Create your models here.\n",
      "line_count": 3
    },
    {
      "name": "models.py",
      "path": "dealer_sync_backend/scraper/models.py",
      "size": 2513,
      "type": "text",
      "content": "from django.db import models\nfrom django.conf import settings\nfrom django.utils import timezone\nfrom django_stubs_ext import WithAnnotations\nimport hashlib\n\n\nclass VehicleListing(models.Model):\n    id = models.AutoField(primary_key=True)\n    user = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        related_name='vehicle_listings',\n        default=1\n    )\n    dealership = models.CharField(max_length=100)\n    title = models.CharField(max_length=500)\n    price = models.DecimalField(\n        max_digits=10, decimal_places=2, null=True, blank=True)\n    msrp = models.DecimalField(\n        max_digits=10, decimal_places=2, null=True, blank=True)\n    year = models.IntegerField()\n    make = models.TextField()\n    model = models.TextField()\n    image_url = models.URLField(max_length=500)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    views = models.IntegerField(default=0)\n    needs_update = models.BooleanField(default=False)\n    dealer_specific_id = models.CharField(max_length=20, unique=True)\n    vin = models.CharField(max_length=17, null=True, blank=True)\n    color = models.CharField(max_length=50, null=True, blank=True)\n\n    class Meta:\n        unique_together = ('year', 'make', 'model', 'dealer_specific_id')\n\n    def __str__(self):\n        return f\"{self.year} {self.make} {self.model} - {self.dealership} (User: {self.user})\"\n\n\nclass SyncAttempt(models.Model):\n    STATUS_CHOICES = [\n        ('PENDING', 'Pending'),\n        ('IN_PROGRESS', 'In Progress'),\n        ('COMPLETED', 'Completed'),\n        ('FAILED', 'Failed'),\n    ]\n\n    user = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        related_name='sync_attempts',\n        default=1\n    )\n    start_time = models.DateTimeField(auto_now_add=True)\n    end_time = models.DateTimeField(null=True, blank=True)\n    status = models.CharField(\n        max_length=20, choices=STATUS_CHOICES, default='PENDING')\n    listings_added = models.IntegerField(default=0)\n    listings_updated = models.IntegerField(default=0)\n    error_message = models.TextField(blank=True, null=True)\n    task_id = models.CharField(max_length=255, null=True, blank=True)\n\n    def __str__(self):\n        return f\"Sync Attempt {self.id} - {self.status} (User: {self.user})\"\n\n    def duration(self):\n        if self.end_time:\n            return self.end_time - self.start_time\n        return timezone.now() - self.start_time\n",
      "line_count": 70
    },
    {
      "name": "models.py",
      "path": "dealer_sync_backend/dashboard/models.py",
      "size": 57,
      "type": "text",
      "content": "from django.db import models\n\n# Create your models here.\n",
      "line_count": 3
    }
  ],
  "directories": [],
  "analysis": {}
}